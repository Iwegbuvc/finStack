// // const mongoose = require("mongoose");
// // const P2PTrade = require("../models/p2pModel");
// // const User = require("../models/userModel");
// // const Wallet = require("../models/walletModel");
// // const blockrader = require("./providers/blockrader"); 

// // const SUPPORTED_ON_PLATFORM = ["NGN", "USD"]; // currencies we hold internally for buyer payout
// // const SUPPORTED_SOURCE_CURRENCIES = ["NGN", "USD", "GHS", "XAF", "XOF", "RMB"]; // currencies buyer can pay with

// // // --------- Helpers ----------

// // /**
// //  * @name resolveUserWalletId
// //  * @description Looks up the Blockrader Address ID (externalWalletId - the UUID) 
// //  * for a given user and currency.
// //  * @param {String} userId - MongoDB ID of the user (Buyer or Merchant)
// //  * @param {String} currency - The currency (e.g., 'USD')
// //  * @returns {String | null} The Blockrader Address ID (externalWalletId) or null.
// //  */
// // async function resolveUserWalletId(userId, currency) {
// //     const userWallet = await Wallet.findOne({ user_id: userId, currency: currency }).lean();
    
// //     if (!userWallet || !userWallet.externalWalletId) {
// //         console.error(`Wallet not found for user ${userId} and currency ${currency}, or externalWalletId (UUID) is missing.`);
// //         return null; 
// //     }
    
// //     // externalWalletId is the Blockrader Address ID (UUID)
// //     return userWallet.externalWalletId; 
// // }

// // /**
// //  * @name resolveUserCryptoAddress
// //  * @description Looks up the crypto address (account_number - the 0x...) 
// //  * for a given user and currency. This address is required by Blockrader API 
// //  * for the 'address' field during transfers.
// //  * @param {String} userId - MongoDB ID of the user
// //  * @param {String} currency - The currency (e.g., 'USD')
// //  * @returns {String | null} The Wallet's crypto address (account_number) or null.
// //  */
// // async function resolveUserCryptoAddress(userId, currency) {
// //     const userWallet = await Wallet.findOne({ user_id: userId, currency: currency }).lean();

// //     // âœ… FIX: Changed to 'accountNumber' to match how it's saved in walletModel in blockrader.js
// //     if (!userWallet || !userWallet.accountNumber) {
// //         console.error(`Wallet not found for user ${userId} and currency ${currency}, or accountNumber (0x address) is missing.`);
// //         return null; 
// //     }

// //     // accountNumber is the Crypto Address (0x...)
// //     return userWallet.accountNumber; 
// // }


// // async function checkUserExists(userId) {
// //   const user = await User.findById(userId).lean();
// //   if (!user) throw new Error("User not found");
// //   return user;
// // }

// // async function isAdmin(userId) {
// //   const u = await User.findById(userId).lean();
// //   return u && u.role === "admin";
// // }

// // function isInternalTrade(trade) {
// //   // "Internal" means buyer is using NGN or USD on-platform (we have internal wallets)
// //   return SUPPORTED_ON_PLATFORM.includes(trade.currencySource);
// // }

// // function safeLog(trade, entry) {
// //   // ensure logs array exists
// //   trade.logs = trade.logs || [];
// //   trade.logs.push({
// //     ...entry,
// //     time: entry.time || new Date()
// //   });
// // }

// // // Basic state machine allowed transitions (enforced where needed)
// // const ALLOWED_STATES = {
// //   INIT: "PENDING_PAYMENT",
// //   ESCROWED_WAIT_MERCHANT: "ESCROWED_AWAITING_MERCHANT_TRANSFER",
// //   PAYMENT_CONFIRMED_BY_BUYER: "PAYMENT_CONFIRMED_BY_BUYER",
// //   COMPLETED: "COMPLETED",
// //   FAILED: "FAILED",
// //   CANCELLED: "CANCELLED",
// //   CANCELLED_REVERSED: "CANCELLED_REVERSED",
// // };

// // // --------- Service functions ----------
// // module.exports = {
// //   /**
// //    * initiateTrade
// //    * - creates trade and, for internal trades, attempts to immediately escrow buyer funds
// //    */
// //   async initiateTrade(buyerId, merchantId, data, ip = null) {
// //     // Basic validations...

// //     // Create initial DB record inside a mongoose session so DB write is atomic.
// //     const session = await mongoose.startSession();
// //     session.startTransaction();
// //     try {
// //       const tradeDoc = await P2PTrade.create(
// //         [
// //           {
// //             reference: data.reference || `REF_${Date.now()}`,
// //             userId: buyerId,
// //             merchantId,
// //             amountSource: data.amountSource,
// //             amountTarget: data.amountTarget,
// //             currencySource: data.currencySource,
// //             currencyTarget: data.currencyTarget,
// //             rate: data.rate || 1,
// //             provider: "BLOCKRADER",
// //             status: ALLOWED_STATES.INIT,
// //             logs: []
// //           }
// //         ],
// //         { session }
// //       );

// //       const trade = tradeDoc[0];

// //       safeLog(trade, { message: "Trade created", actor: buyerId, role: "buyer", ip, time: new Date() });

// //       // If buyer is using an internal (supported) currency, immediately move buyer funds to company escrow.
// //       if (isInternalTrade(trade)) {
// //         // Resolve the buyer wallet UUID (Address ID) for the SOURCE
// //         const buyerSourceId = await resolveUserWalletId(buyerId, trade.currencySource);
// //         if (!buyerSourceId) {
// //           throw new Error("Buyer does not have a wallet for currencySource");
// //         }

// //         // Destination for escrow is the Master Wallet. We pass the Master Wallet's 0x address.
// //         const masterWalletCryptoAddress = blockrader.ESCROW_DESTINATION_ADDRESS;
// //         if (!masterWalletCryptoAddress) {
// //             throw new Error("FATAL: MASTER_WALLET_ADDRESS is missing in environment variables for escrow.");
// //         }


// //         // Perform the external provider call (escrow transfer).
// //         // This is a Child -> Master transfer (Escrow)
// //         const transferResult = await blockrader.transferFunds(
// //           buyerSourceId, // Source: User Wallet UUID
// //           blockrader.BLOCKRADER_MASTER_WALLET_UUID, // Destination: Master Wallet UUID
// //           trade.amountSource,
// //           trade.currencySource,
// //           masterWalletCryptoAddress // Pass the required Master Wallet 0x Address
// //         );

// //         // Expect transferResult success/txId; otherwise throw
// //         if (!transferResult || (!transferResult.success && !transferResult.txId)) {
// //           throw new Error("Failed to escrow buyer funds");
// //         }

// //         // update trade status + logs
// //         trade.status = ALLOWED_STATES.ESCROWED_WAIT_MERCHANT;
// //         safeLog(trade, {
// //           message: `Buyer funds escrowed (${trade.amountSource} ${trade.currencySource}) tx:${transferResult.txId || "n/a"}`,
// //           actor: buyerId,
// //           role: "buyer",
// //           ip,
// //           time: new Date()
// //         });

// //         // persist change
// //         await trade.save({ session });
// //       } else {
// //         // External fiat: buyer will pay off-platform; we wait for buyer confirmation
// //         safeLog(trade, { message: "External trade initiated (awaiting buyer payment)", actor: buyerId, role: "buyer", ip });
// //         await trade.save({ session });
// //       }

// //       await session.commitTransaction();
// //       session.endSession();

// //       // return fresh trade from db (lean)
// //       return await P2PTrade.findById(trade._id).lean();
// //     } catch (err) {
// //       await session.abortTransaction();
// //       session.endSession();
// //       // If we called an external transfer and it partially succeeded, consider implementing compensating logic here
// //       throw err;
// //     }
// //   },

// //   /**
// //    * confirmBuyerPayment
// //    * - Used when buyer paid off-platform (external fiat) and clicks "I've paid".
// //    */
// //   async confirmBuyerPayment(reference, buyerId, ip = null) {
// //     if (!reference) throw new Error("reference required");
// //     const trade = await P2PTrade.findOne({ reference });
// //     if (!trade) throw new Error("Trade not found");

// //     // Guard: cannot be used for internal trades
// //     if (isInternalTrade(trade)) {
// //       throw new Error("This flow is for external fiat payments only");
// //     }

// //     // Ensure correct actor and state...

// //     // Now we need to escrow merchant's asset (target currency) into company escrow.
// //     // Merchant must have an internal wallet for currencyTarget.
    
// //     // Get the merchant's wallet UUID (Address ID) for the SOURCE
// //     const merchantWalletId = await resolveUserWalletId(trade.merchantId, trade.currencyTarget);
// //     if (!merchantWalletId) {
// //       throw new Error("Merchant does not have a wallet for the target currency (Address ID missing in DB)");
// //     }

// //     // Destination for escrow is the Master Wallet. We pass the Master Wallet's 0x address.
// //     const masterWalletCryptoAddress = blockrader.ESCROW_DESTINATION_ADDRESS;
// //     if (!masterWalletCryptoAddress) {
// //         throw new Error("FATAL: MASTER_WALLET_ADDRESS is missing in environment variables for escrow.");
// //     }
    
// //     // Call provider: move merchant asset -> company escrow (so buyer's external payment can be matched)
// //     // This is a Child -> Master transfer (Escrow)
// //     const transferResult = await blockrader.transferFunds(
// //       merchantWalletId, // Source: Merchant Wallet UUID
// //       blockrader.BLOCKRADER_MASTER_WALLET_UUID, // Destination: Master Wallet UUID
// //       trade.amountTarget,
// //       trade.currencyTarget,
// //       masterWalletCryptoAddress // Pass the required Master Wallet 0x Address
// //     );

// //     if (!transferResult || (!transferResult.success && !transferResult.txId)) {
// //       throw new Error("Failed to escrow merchant funds");
// //     }

// //     // Update DB...
// //     trade.status = ALLOWED_STATES.PAYMENT_CONFIRMED_BY_BUYER;
// //     safeLog(trade, {
// //       message: `Buyer confirmed external payment; merchant asset escrowed (tx:${transferResult.txId || "n/a"})`,
// //       actor: buyerId,
// //       role: "buyer",
// //       ip,
// //       time: new Date()
// //     });
// //     await trade.save();

// //     return trade.toObject();
// //   },

// //   /**
// //    * confirmMerchantPayment
// //    * - This triggers the release from escrow to the rightful recipient.
// //    */
// //   async confirmMerchantPayment(reference, merchantId, ip = null) {
// //     if (!reference) throw new Error("reference required");
// //     const trade = await P2PTrade.findOne({ reference });
// //     if (!trade) throw new Error("Trade not found");

// //     // Authorization...

// //     const internal = isInternalTrade(trade);

// //     // Validate expected status...

// //     // Settlement: release appropriate funds from escrow
// //     if (internal) {
// //       // Buyer funds are in escrow (in currencySource) -> release to merchant's source wallet
      
// //       // 1. Get Merchant's UUID (Destination ID)
// //       const merchantDestinationId = await resolveUserWalletId(trade.merchantId, trade.currencySource);
// //       if (!merchantDestinationId) throw new Error("Merchant missing destination Address ID for source currency");
      
// //       // 2. Get Merchant's Crypto Address (REQUIRED for Blockrader's 'address' field)
// //       const merchantCryptoAddress = await resolveUserCryptoAddress(trade.merchantId, trade.currencySource);
// //       if (!merchantCryptoAddress) throw new Error("Merchant missing destination crypto address for source currency");

// //       // Pass the required 0x destination address. Source is the Master Wallet.
// //       // This is a Master -> Child transfer (Settlement)
// //       const transferResult = await blockrader.transferFunds(
// //         blockrader.BLOCKRADER_MASTER_WALLET_UUID, // Source: Master Wallet UUID
// //         merchantDestinationId, // Destination: Merchant UUID (used for routing)
// //         trade.amountSource,
// //         trade.currencySource,
// //         merchantCryptoAddress // Pass the required 0x destination address
// //       );

// //       if (!transferResult || (!transferResult.success && !transferResult.txId)) {
// //         throw new Error("Failed to release buyer funds to merchant");
// //       }

// //       safeLog(trade, {
// //         message: `Internal settlement: buyer funds released to merchant (tx:${transferResult.txId || "n/a"})`,
// //         actor: merchantId,
// //         role: "merchant",
// //         ip,
// //         time: new Date()
// //       });

// //     } else {
// //       // External: merchant's asset already escrowed (amountTarget) -> release it to buyer's wallet
      
// //       // 1. Get Buyer's UUID (Destination ID)
// //       const buyerDestinationId = await resolveUserWalletId(trade.userId, trade.currencyTarget);
// //       if (!buyerDestinationId) throw new Error("Buyer missing destination Address ID for target currency");

// //       // 2. Get Buyer's Crypto Address (REQUIRED for Blockrader's 'address' field)
// //       const buyerCryptoAddress = await resolveUserCryptoAddress(trade.userId, trade.currencyTarget);
// //       if (!buyerCryptoAddress) throw new Error("Buyer missing destination crypto address for target currency");

// //       // Pass the required 0x destination address. Source is the Master Wallet.
// //       // This is a Master -> Child transfer (Settlement)
// //       const transferResult = await blockrader.transferFunds(
// //         blockrader.BLOCKRADER_MASTER_WALLET_UUID, // Source: Master Wallet UUID
// //         buyerDestinationId, // Destination: Buyer UUID (used for routing)
// //         trade.amountTarget,
// //         trade.currencyTarget,
// //         buyerCryptoAddress // Pass the required 0x destination address
// //       );

// //       if (!transferResult || (!transferResult.success && !transferResult.txId)) {
// //         throw new Error("Failed to release escrowed asset to buyer");
// //       }

// //       safeLog(trade, {
// //         message: `External settlement: merchant escrow released to buyer (tx:${transferResult.txId || "n/a"})`,
// //         actor: merchantId,
// //         role: "merchant",
// //         ip,
// //         time: new Date()
// //       });
// //     }

// //     trade.status = ALLOWED_STATES.COMPLETED;
// //     trade.updatedAt = new Date();
// //     await trade.save();

// //     return trade.toObject();
// //   },

// //   /**
// //    * cancelTrade
// //    * - Attempt safe cancellation and reversal when permissible.
// //    */
// //   async cancelTrade(reference, userId, ip = null) {
// //     // ... Authorization and guards ...
// //     if (!reference) throw new Error("reference required");
// //     const trade = await P2PTrade.findOne({ reference });
// //     if (!trade) throw new Error("Trade not found");

// //     // Authorization...
// //     if (trade.userId.toString() !== userId.toString() && !(await isAdmin(userId))) {
// //       throw new Error("Not authorized to cancel this trade");
// //     }

// //     // Prevent cancelling after completion
// //     if (trade.status === ALLOWED_STATES.COMPLETED) {
// //       throw new Error("Cannot cancel a completed trade");
// //     }

// //     const internal = isInternalTrade(trade);

// //     // If funds were escrowed, attempt reversal
// //     if (trade.status === ALLOWED_STATES.ESCROWED_WAIT_MERCHANT && internal) {
// //       // Reverse buyer funds from escrow back to buyer
      
// //       // 1. Get Buyer's UUID (Destination ID)
// //       const buyerDestinationId = await resolveUserWalletId(trade.userId, trade.currencySource);
// //       if (!buyerDestinationId) {
// //         // Can't reverse: log and set flagged
// //         trade.logs.push({ message: "Escrow reversal failed - buyer wallet missing", actor: userId, role: "system", ip, time: new Date() });
// //         trade.status = ALLOWED_STATES.FAILED;
// //         await trade.save();
// //         throw new Error("Escrow reversal failed: buyer destination address missing");
// //       }

// //       // 2. Get Buyer's Crypto Address (REQUIRED for Blockrader's 'address' field)
// //       const buyerCryptoAddress = await resolveUserCryptoAddress(trade.userId, trade.currencySource);
// //       if (!buyerCryptoAddress) {
// //         trade.status = ALLOWED_STATES.FAILED;
// //         await trade.save();
// //         throw new Error("Escrow reversal failed: buyer crypto address missing");
// //       }

// //       // Pass the required 0x destination address. Source is the Master Wallet.
// //       // This is a Master -> Child transfer (Reversal)
// //       const transferResult = await blockrader.transferFunds(
// //         blockrader.BLOCKRADER_MASTER_WALLET_UUID, // Source: Master Wallet UUID
// //         buyerDestinationId, // Destination: Buyer UUID (used for routing)
// //         trade.amountSource,
// //         trade.currencySource,
// //         buyerCryptoAddress // Pass the required 0x address
// //       );

// //       if (!transferResult || (!transferResult.success && !transferResult.txId)) {
// //         trade.logs.push({ message: "Escrow reversal failed at provider", actor: userId, role: "system", ip, time: new Date() });
// //         trade.status = ALLOWED_STATES.FAILED;
// //         await trade.save();
// //         throw new Error("Escrow reversal failed at provider");
// //       }

// //       trade.status = ALLOWED_STATES.CANCELLED_REVERSED;
// //       safeLog(trade, { message: `Internal escrow reversed (tx:${transferResult.txId || "n/a"})`, actor: userId, role: "buyer", ip, time: new Date() });
// //       await trade.save();
// //       return trade.toObject();
// //     }

// //     // If merchant escrowed for external case (PAYMENT_CONFIRMED_BY_BUYER), reverse merchant escrow
// //     if (trade.status === ALLOWED_STATES.PAYMENT_CONFIRMED_BY_BUYER && !internal) {
      
// //       // 1. Get Merchant's UUID (Destination ID)
// //       const merchantDestinationId = await resolveUserWalletId(trade.merchantId, trade.currencyTarget);
// //       if (!merchantDestinationId) {
// //         trade.status = ALLOWED_STATES.FAILED;
// //         await trade.save();
// //         throw new Error("Merchant destination Address ID missing for reversal");
// //       }
      
// //       // 2. Get Merchant's Crypto Address (REQUIRED for Blockrader's 'address' field)
// //       const merchantCryptoAddress = await resolveUserCryptoAddress(trade.merchantId, trade.currencyTarget);
// //       if (!merchantCryptoAddress) {
// //         trade.status = ALLOWED_STATES.FAILED;
// //         await trade.save();
// //         throw new Error("Merchant crypto address missing for reversal");
// //       }

// //       // Pass the required 0x destination address. Source is the Master Wallet.
// //       // This is a Master -> Child transfer (Reversal)
// //       const transferResult = await blockrader.transferFunds(
// //         blockrader.BLOCKRADER_MASTER_WALLET_UUID, // Source: Master Wallet UUID
// //         merchantDestinationId, // Destination: Merchant UUID (used for routing)
// //         trade.amountTarget,
// //         trade.currencyTarget,
// //         merchantCryptoAddress // Pass the required 0x destination address
// //       );

// //       if (!transferResult || (!transferResult.success && !transferResult.txId)) {
// //         trade.status = ALLOWED_STATES.FAILED;
// //         await trade.save();
// //         throw new Error("Escrow reversal failed at provider");
// //       }

// //       trade.status = ALLOWED_STATES.CANCELLED_REVERSED;
// //       safeLog(trade, { message: `External escrow reversed (tx:${transferResult.txId || "n/a"})`, actor: userId, role: "system", ip, time: new Date() });
// //       await trade.save();
// //       return trade.toObject();
// //     }

// //     // Generic cancel if nothing to reverse
// //     trade.status = ALLOWED_STATES.CANCELLED;
// //     safeLog(trade, { message: "Trade cancelled (no reversal needed)", actor: userId, role: "requester", ip, time: new Date() });
// //     await trade.save();
// //     return trade.toObject();
// //   },

// //   // Utility helpers for admin / UI
// //   async getTradeByReference(reference) {
// //     return await P2PTrade.findOne({ reference }).populate("userId", "firstName email role").populate("merchantId", "firstName email role").lean();
// //   },

// //   async listTrades(filter = {}, page = 1, pageSize = 20) {
// //     const q = {};
// //     if (filter.status) q.status = filter.status;
// //     if (filter.userId) q.userId = filter.userId;
// //     if (filter.merchantId) q.merchantId = filter.merchantId;

// //     const [trades, total] = await Promise.all([
// //       P2PTrade.find(q).sort({ createdAt: -1 }).skip((page - 1) * pageSize).limit(pageSize).lean(),
// //       P2PTrade.countDocuments(q)
// //     ]);

// //     return { trades, total, page, pageSize };
// //   }
// // };


// ANOTHER ANGLE lates
const mongoose = require("mongoose");
const P2PTrade = require("../models/p2pModel");
const User = require("../models/userModel");
const Wallet = require("../models/walletModel");
const blockrader = require("./providers/blockrader");Â 

const SUPPORTED_ON_PLATFORM = ["NGN", "USD"]; // currencies we hold internally for buyer payout
const SUPPORTED_SOURCE_CURRENCIES = ["NGN", "USD", "GHS", "XAF", "XOF", "RMB"]; // currencies buyer can pay with

// --------- Helpers ----------

/**
Â * @name resolveUserWalletId
Â * @description Looks up the Blockrader Address ID (externalWalletId - the UUID)Â 
Â * for a given user and currency.
Â * @param {String} userId - MongoDB ID of the user (Buyer or Merchant)
Â * @param {String} currency - The currency (e.g., 'USD')
Â * @returns {String | null} The Blockrader Address ID (externalWalletId) or null.
Â */
async function resolveUserWalletId(userId, currency) {
Â  Â  const userWallet = await Wallet.findOne({ user_id: userId, currency: currency }).lean();
Â  Â Â 
Â  Â  if (!userWallet || !userWallet.externalWalletId) {
Â  Â  Â  Â  // FIX: Use template literals (backticks)
Â  Â  Â  Â  console.error(`Wallet not found for user ${userId} and currency ${currency}, or externalWalletId (UUID) is missing.`);
Â  Â  Â  Â  return null;Â 
Â  Â  }
Â  Â Â 
Â  Â  // externalWalletId is the Blockrader Address ID (UUID)
Â  Â  return userWallet.externalWalletId;Â 
}

/**
Â * @name resolveUserCryptoAddress
Â * @description Looks up the crypto address (account_number - the 0x...)Â 
Â * for a given user and currency. This address is required by Blockrader APIÂ 
Â * for the 'address' field during transfers.
Â * @param {String} userId - MongoDB ID of the user
Â * @param {String} currency - The currency (e.g., 'USD')
Â * @returns {String | null} The Wallet's crypto address (account_number) or null.
Â */
async function resolveUserCryptoAddress(userId, currency) {
Â  Â  const userWallet = await Wallet.findOne({ user_id: userId, currency: currency }).lean();

Â  Â  if (!userWallet || !userWallet.accountNumber) {
Â  Â  Â  Â  // FIX: Use template literals (backticks)
Â  Â  Â  Â  console.error(`Wallet not found for user ${userId} and currency ${currency}, or accountNumber (0x address) is missing.`);
Â  Â  Â  Â  return null;Â 
Â  Â  }

Â  Â  // accountNumber is the Crypto Address (0x...)
Â  Â  return userWallet.accountNumber;Â 
}


async function checkUserExists(userId) {
Â  const user = await User.findById(userId).lean();
Â  if (!user) throw new Error("User not found");
Â  return user;
}

async function isAdmin(userId) {
Â  const u = await User.findById(userId).lean();
Â  return u && u.role === "admin";
}

function isInternalTrade(trade) {
Â  // "Internal" means buyer is using NGN or USD on-platform (we have internal wallets)
Â  return SUPPORTED_ON_PLATFORM.includes(trade.currencySource);
}

function safeLog(trade, entry) {
Â  // ensure logs array exists
Â  trade.logs = trade.logs || [];
Â  trade.logs.push({
Â  Â  ...entry,
Â  Â  time: entry.time || new Date()
Â  });
}

// Basic state machine allowed transitions (enforced where needed)
const ALLOWED_STATES = {
Â  INIT: "PENDING_PAYMENT",
Â  ESCROWED_WAIT_MERCHANT: "ESCROWED_AWAITING_MERCHANT_TRANSFER",
Â  PAYMENT_CONFIRMED_BY_BUYER: "PAYMENT_CONFIRMED_BY_BUYER",
Â  COMPLETED: "COMPLETED",
Â  FAILED: "FAILED",
Â  CANCELLED: "CANCELLED",
Â  CANCELLED_REVERSED: "CANCELLED_REVERSED",
};

// --------- Service functions ----------
module.exports = {
Â  /**
Â  Â * initiateTrade
Â  Â * - creates trade and, for internal trades, attempts to immediately escrow buyer funds
Â  Â */
Â  async initiateTrade(buyerId, merchantId, data, ip = null) {
Â  Â  // Basic validations...

Â  Â  // Create initial DB record inside a mongoose session so DB write is atomic.
Â  Â  const session = await mongoose.startSession();
Â  Â  session.startTransaction();
Â  Â  try {
Â  Â  Â  const tradeDoc = await P2PTrade.create(
Â  Â  Â  Â  [
Â  Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  reference: data.reference || `REF_${Date.now()}`,
Â  Â  Â  Â  Â  Â  userId: buyerId,
Â  Â  Â  Â  Â  Â  merchantId,
Â  Â  Â  Â  Â  Â  amountSource: data.amountSource,
Â  Â  Â  Â  Â  Â  amountTarget: data.amountTarget,
Â  Â  Â  Â  Â  Â  currencySource: data.currencySource,
Â  Â  Â  Â  Â  Â  currencyTarget: data.currencyTarget,
Â  Â  Â  Â  Â  Â  rate: data.rate || 1,
Â  Â  Â  Â  Â  Â  provider: "BLOCKRADER",
Â  Â  Â  Â  Â  Â  status: ALLOWED_STATES.INIT,
Â  Â  Â  Â  Â  Â  logs: []
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  ],
Â  Â  Â  Â  { session }
Â  Â  Â  );

Â  Â  Â  const trade = tradeDoc[0];

Â  Â  Â  safeLog(trade, { message: "Trade created", actor: buyerId, role: "buyer", ip, time: new Date() });

Â  Â  Â  // If buyer is using an internal (supported) currency, immediately move buyer funds to company escrow.
Â  Â  Â  if (isInternalTrade(trade)) {
Â  Â  Â  Â  // Resolve the buyer wallet UUID (Address ID) for the SOURCE
Â  Â  Â  Â  const buyerSourceId = await resolveUserWalletId(buyerId, trade.currencySource);
Â  Â  Â  Â  if (!buyerSourceId) {
Â  Â  Â  Â  Â  throw new Error("Buyer does not have a wallet for currencySource");
Â  Â  Â  Â  }

Â  Â  Â  Â  // Destination for escrow is the Master Wallet. We pass the Master Wallet's 0x address.
Â  Â  Â  Â  const masterWalletCryptoAddress = blockrader.ESCROW_DESTINATION_ADDRESS;
Â  Â  Â  Â  if (!masterWalletCryptoAddress) {
Â  Â  Â  Â  Â  Â  throw new Error("FATAL: MASTER_WALLET_ADDRESS is missing in environment variables for escrow.");
Â  Â  Â  Â  }


Â  Â  Â  Â  // Perform the external provider call (escrow transfer).
Â  Â  Â  Â  // This is a Child -> Master transfer (Escrow)
Â  Â  Â  Â  const transferResult = await blockrader.transferFunds(
Â  Â  Â  Â  Â  buyerSourceId, // Source: User Wallet UUID
Â  Â  Â  Â  Â  blockrader.BLOCKRADER_MASTER_WALLET_UUID, // Destination: Master Wallet UUID
Â  Â  Â  Â  Â  trade.amountSource,
Â  Â  Â  Â  Â  trade.currencySource,
Â  Â  Â  Â  Â  masterWalletCryptoAddress // Pass the required Master Wallet 0x Address
Â  Â  Â  Â  );

Â  Â  Â  Â  // --- FIX 1 (InitiateTrade): Check for successful API response structure (data.id) ---
Â  Â  Â  Â  if (!transferResult || !transferResult.data || !transferResult.data.id) {
Â  Â  Â  Â  Â  Â  // FIX: Use template literals (backticks)
Â  Â  Â  Â  Â  Â  const errorMessage = `Failed to escrow buyer funds. Provider response: ${JSON.stringify(transferResult)}`;
Â  Â  Â  Â  Â  Â  console.error(errorMessage);
Â  Â  Â  Â  Â  Â  throw new Error("Failed to escrow buyer funds: Provider API initiation failed.");
Â  Â  Â  Â  }
Â  Â  Â  Â  // --- End Fix 1 ---
Â  Â  Â  Â Â 
Â  Â  Â  Â  const txId = transferResult.data.id || transferResult.txId || "n/a"; // Use the internal ID or a fallback

Â  Â  Â  Â  // update trade status + logs
Â  Â  Â  Â  trade.status = ALLOWED_STATES.ESCROWED_WAIT_MERCHANT;
Â  Â  Â  Â  safeLog(trade, {
Â  Â  Â  Â  Â  // FIX: Use template literals (backticks)
Â  Â  Â  Â  Â  message: `Buyer funds escrowed (${trade.amountSource} ${trade.currencySource}) tx:${txId}`,
Â  Â  Â  Â  Â  actor: buyerId,
Â  Â  Â  Â  Â  role: "buyer",
Â  Â  Â  Â  Â  ip,
Â  Â  Â  Â  Â  time: new Date()
Â  Â  Â  Â  });

Â  Â  Â  Â  // persist change
Â  Â  Â  Â  await trade.save({ session });
Â  Â  Â  } else {
Â  Â  Â  Â  // External fiat: buyer will pay off-platform; we wait for buyer confirmation
Â  Â  Â  Â  safeLog(trade, { message: "External trade initiated (awaiting buyer payment)", actor: buyerId, role: "buyer", ip });
Â  Â  Â  Â  await trade.save({ session });
Â  Â  Â  }

Â  Â  Â  await session.commitTransaction();
Â  Â  Â  session.endSession();

Â  Â  Â  // return fresh trade from db (lean)
Â  Â  Â  return await P2PTrade.findById(trade._id).lean();
Â  Â  } catch (err) {
Â  Â  Â  await session.abortTransaction();
Â  Â  Â  session.endSession();
Â  Â  Â  // If we called an external transfer and it partially succeeded, consider implementing compensating logic here
Â  Â  Â  throw err;
Â  Â  }
Â  },

Â  /**
Â  Â * confirmBuyerPayment
Â  Â * - Used when buyer paid off-platform (external fiat) and clicks "I've paid".
Â  Â */
Â  async confirmBuyerPayment(reference, buyerId, ip = null) {
Â  Â  if (!reference) throw new Error("reference required");
Â  Â  const trade = await P2PTrade.findOne({ reference });
Â  Â  if (!trade) throw new Error("Trade not found");

Â  Â  // Guard: cannot be used for internal trades
Â  Â  if (isInternalTrade(trade)) {
Â  Â  Â  throw new Error("This flow is for external fiat payments only");
Â  Â  }

Â  Â  // Ensure correct actor and state...

Â  Â  // Now we need to escrow merchant's asset (target currency) into company escrow.
Â  Â  // Merchant must have an internal wallet for currencyTarget.
Â  Â Â 
Â  Â  // Get the merchant's wallet UUID (Address ID) for the SOURCE
Â  Â  const merchantWalletId = await resolveUserWalletId(trade.merchantId, trade.currencyTarget);
Â  Â  if (!merchantWalletId) {
Â  Â  Â  throw new Error("Merchant does not have a wallet for the target currency (Address ID missing in DB)");
Â  Â  }

Â  Â  // Destination for escrow is the Master Wallet. We pass the Master Wallet's 0x address.
Â  Â  const masterWalletCryptoAddress = blockrader.ESCROW_DESTINATION_ADDRESS;
Â  Â  if (!masterWalletCryptoAddress) {
Â  Â  Â  Â  throw new Error("FATAL: MASTER_WALLET_ADDRESS is missing in environment variables for escrow.");
Â  Â  }
Â  Â Â 
Â  Â  // Call provider: move merchant asset -> company escrow (so buyer's external payment can be matched)
Â  Â  // This is a Child -> Master transfer (Escrow)
Â  Â  const transferResult = await blockrader.transferFunds(
Â  Â  Â  merchantWalletId, // Source: Merchant Wallet UUID
Â  Â  Â  blockrader.BLOCKRADER_MASTER_WALLET_UUID, // Destination: Master Wallet UUID
Â  Â  Â  trade.amountTarget,
Â  Â  Â  trade.currencyTarget,
Â  Â  Â  masterWalletCryptoAddress // Pass the required Master Wallet 0x Address
Â  Â  );

Â  Â  // --- FIX 1 (ConfirmBuyerPayment): Check for successful API response structure (data.id) ---
Â  Â  if (!transferResult || !transferResult.data || !transferResult.data.id) {
Â  Â  Â  // FIX: Use template literals (backticks)
Â  Â  Â  const errorMessage = `Failed to escrow merchant funds. Provider response: ${JSON.stringify(transferResult)}`;
Â  Â  Â  console.error(errorMessage);
Â  Â  Â  throw new Error("Failed to escrow merchant funds: Provider API initiation failed.");
Â  Â  }
Â  Â  // --- End Fix 1 ---
Â  Â Â 
Â  Â  const txId = transferResult.data.id || transferResult.txId || "n/a"; // Use the internal ID or a fallback

Â  Â  // Update DB...
Â  Â  trade.status = ALLOWED_STATES.PAYMENT_CONFIRMED_BY_BUYER;
Â  Â  safeLog(trade, {
Â  Â  Â  // FIX: Use template literals (backticks)
Â  Â  Â  message: `Buyer confirmed external payment; merchant asset escrowed (tx:${txId})`,
Â  Â  Â  actor: buyerId,
Â  Â  Â  role: "buyer",
Â  Â  Â  ip,
Â  Â  Â  time: new Date()
Â  Â  });
Â  Â  // Immediate save to prevent webhook race condition
Â  Â  await trade.save();

Â  Â  return trade.toObject();
Â  },

Â  /**
Â  Â * confirmMerchantPayment
Â  Â * - This triggers the release from escrow to the rightful recipient.
Â  Â */
Â  async confirmMerchantPayment(reference, merchantId, ip = null) {
Â  Â  if (!reference) throw new Error("reference required");
Â  Â  const trade = await P2PTrade.findOne({ reference });
Â  Â  if (!trade) throw new Error("Trade not found");

Â  Â  // Authorization...

Â  Â  const internal = isInternalTrade(trade);

Â  Â  // Validate expected status...

Â  Â  let transferResult = null;
Â  Â  let transferFailed = false;
Â  Â  let txId = "n/a";

Â  Â  // Settlement: release appropriate funds from escrow
Â  Â  if (internal) {
Â  Â  Â  // Internal settlement logic remains largely the same...
Â  Â  Â  // ...
Â  Â  } else {
Â  Â  Â  // External: merchant's asset already escrowed (amountTarget) -> release it to buyer's wallet
Â  Â  Â Â 
Â  Â  Â  // 1. Get Buyer's UUID (Destination ID)
Â  Â  Â  const buyerDestinationId = await resolveUserWalletId(trade.userId, trade.currencyTarget);
Â  Â  Â  if (!buyerDestinationId) throw new Error("Buyer missing destination Address ID for target currency");

Â  Â  Â  // 2. Get Buyer's Crypto Address (REQUIRED for Blockrader's 'address' field)
Â  Â  Â  const buyerCryptoAddress = await resolveUserCryptoAddress(trade.userId, trade.currencyTarget);
Â  Â  Â  if (!buyerCryptoAddress) throw new Error("Buyer missing destination crypto address for target currency");

Â  Â  Â  // Pass the required 0x destination address. Source is the Master Wallet.
Â  Â  Â  // This is a Master -> Child transfer (Settlement)
Â  Â  Â  transferResult = await blockrader.transferFunds(
Â  Â  Â  Â  blockrader.BLOCKRADER_MASTER_WALLET_UUID, // Source: Master Wallet UUID
Â  Â  Â  Â  buyerDestinationId, // Destination: Buyer UUID (used for routing)
Â  Â  Â  Â  trade.amountTarget,
Â  Â  Â  Â  trade.currencyTarget,
Â  Â  Â  Â  buyerCryptoAddress // Pass the required 0x destination address
Â  Â  Â  );

Â  Â  Â  // --- CRITICAL FIX 1: Check for successful API response structure (data.id) ---
Â  Â  Â  // This is the check that was failing because the API returned PENDING status initially.
Â  Â  Â  if (!transferResult || !transferResult.data || !transferResult.data.id) {
Â  Â  Â  Â  // FIX: Use template literals (backticks)
Â  Â  Â  Â  const errorMessage = `Failed to release escrowed asset to buyer (External settlement). Provider response: ${JSON.stringify(transferResult)}`;
Â  Â  Â  Â  console.error(errorMessage);
Â  Â  Â  Â  transferFailed = true;
Â  Â  Â  }
Â  Â  Â  // --- End Critical Fix 1 ---
Â  Â  Â Â 
Â  Â  Â  if (!transferFailed) {
Â  Â  Â  Â  txId = transferResult.data.id || transferResult.txId || "n/a";
Â  Â  Â  Â  safeLog(trade, {
Â  Â  Â  Â  Â  // FIX: Use template literals (backticks)
Â  Â  Â  Â  Â  message: `External settlement initiated to buyer (tx:${txId}). Awaiting webhook confirmation.`,
Â  Â  Â  Â  Â  actor: merchantId,
Â  Â  Â  Â  Â  role: "merchant",
Â  Â  Â  Â  Â  ip,
Â  Â  Â  Â  Â  time: new Date()
Â  Â  Â  Â  });
Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  // --- CRITICAL FIX 2: Immediate save to COMPLETED status to beat the webhook ---
Â  Â  // We mark the trade as COMPLETED immediately upon successful initiation of the transfer.
Â  Â  // The webhook only confirms the underlying transaction is final.
Â  Â  trade.status = ALLOWED_STATES.COMPLETED;
Â  Â  trade.updatedAt = new Date();
Â  Â  await trade.save();
Â  Â  // --- End Critical Fix 2 ---

Â  Â  if (transferFailed) {
Â  Â  Â  Â  // If the initiation failed (e.g., Blockrader API was down), we throw the error AFTER saving the COMPLETED statusÂ 
Â  Â  Â  Â  // in case the webhook still arrives and finds the trade completed.
Â  Â  Â  Â  // NOTE: The webhook handler now contains logic to revert the status if a 'transfer.failed' event is received.
Â  Â  Â  Â  throw new Error("Settlement transfer initiation failed at provider.");
Â  Â  }


Â  Â  return trade.toObject();
Â  },

Â  /**
Â  Â * cancelTrade
Â  Â * - Attempt safe cancellation and reversal when permissible.
Â  Â */
Â  async cancelTrade(reference, userId, ip = null) {
Â  Â  // ... Authorization and guards ...
Â  Â  if (!reference) throw new Error("reference required");
Â  Â  const trade = await P2PTrade.findOne({ reference });
Â  Â  if (!trade) throw new Error("Trade not found");

Â  Â  // Authorization...
Â  Â  if (trade.userId.toString() !== userId.toString() && !(await isAdmin(userId))) {
Â  Â  Â  throw new Error("Not authorized to cancel this trade");
Â  Â  }

Â  Â  // Prevent cancelling after completion
Â  Â  if (trade.status === ALLOWED_STATES.COMPLETED) {
Â  Â  Â  throw new Error("Cannot cancel a completed trade");
Â  Â  }

Â  Â  const internal = isInternalTrade(trade);
Â  Â  let reversalSuccess = false;

Â  Â  // If funds were escrowed, attempt reversal
Â  Â  if (trade.status === ALLOWED_STATES.ESCROWED_WAIT_MERCHANT && internal) {
Â  Â  Â  // Reverse buyer funds from escrow back to buyer
Â  Â  Â Â 
Â  Â  Â  // 1. Get Buyer's UUID (Destination ID)
Â  Â  Â  const buyerDestinationId = await resolveUserWalletId(trade.userId, trade.currencySource);
Â  Â  Â  if (!buyerDestinationId) {
Â  Â  Â  Â  // Can't reverse: log and set flagged
Â  Â  Â  Â  trade.logs.push({ message: "Escrow reversal failed - buyer wallet missing (Destination ID)", actor: userId, role: "system", ip, time: new Date() });
Â  Â  Â  Â  trade.status = ALLOWED_STATES.FAILED;
Â  Â  Â  Â  await trade.save();
Â  Â  Â  Â  throw new Error("Escrow reversal failed: buyer destination address ID missing");
Â  Â  Â  }

Â  Â  Â  // 2. Get Buyer's Crypto Address (REQUIRED for Blockrader's 'address' field)
Â  Â  Â  const buyerCryptoAddress = await resolveUserCryptoAddress(trade.userId, trade.currencySource);
Â  Â  Â  if (!buyerCryptoAddress) {
Â  Â  Â  Â  trade.status = ALLOWED_STATES.FAILED;
Â  Â  Â  Â  await trade.save();
Â  Â  Â  Â  throw new Error("Escrow reversal failed: buyer crypto address missing");
Â  Â  Â  }

Â  Â  Â  // Pass the required 0x destination address. Source is the Master Wallet.
Â  Â  Â  // This is a Master -> Child transfer (Reversal)
Â  Â  Â  const transferResult = await blockrader.transferFunds(
Â  Â  Â  Â  blockrader.BLOCKRADER_MASTER_WALLET_UUID, // Source: Master Wallet UUID
Â  Â  Â  Â  buyerDestinationId, // Destination: Buyer UUID (used for routing)
Â  Â  Â  Â  trade.amountSource,
Â  Â  Â  Â  trade.currencySource,
Â  Â  Â  Â  buyerCryptoAddress // Pass the required 0x address
Â  Â  Â  );

Â  Â  Â  // --- FIX 1 (CancelTrade Internal): Check for successful API response structure (data.id) ---
Â  Â  Â  if (!transferResult || !transferResult.data || !transferResult.data.id) {
Â  Â  Â  Â  // FIX: Use template literals (backticks)
Â  Â  Â  Â  const errorMessage = `Internal Escrow reversal failed at provider. Provider response: ${JSON.stringify(transferResult)}`;
Â  Â  Â  Â  console.error(errorMessage);
Â  Â  Â  Â  trade.logs.push({ message: "Escrow reversal failed at provider", actor: userId, role: "system", ip, time: new Date() });
Â  Â  Â  Â  trade.status = ALLOWED_STATES.FAILED;
Â  Â  Â  Â  await trade.save();
Â  Â  Â  Â  throw new Error("Escrow reversal failed at provider");
Â  Â  Â  }
Â  Â  Â  // --- End Fix 1 ---
Â  Â  Â Â 
Â  Â  Â  const txId = transferResult.data.id || transferResult.txId || "n/a";
Â  Â  Â  trade.status = ALLOWED_STATES.CANCELLED_REVERSED;
Â  Â  Â  // FIX: Use template literals (backticks)
Â  Â  Â  safeLog(trade, { message: `Internal escrow reversed (tx:${txId})`, actor: userId, role: "buyer", ip, time: new Date() });
Â  Â  Â  reversalSuccess = true;
Â  Â  }

Â  Â  // If merchant escrowed for external case (PAYMENT_CONFIRMED_BY_BUYER), reverse merchant escrow
Â  Â  if (trade.status === ALLOWED_STATES.PAYMENT_CONFIRMED_BY_BUYER && !internal) {
Â  Â  Â Â 
Â  Â  Â  // 1. Get Merchant's UUID (Destination ID)
Â  Â  Â  const merchantDestinationId = await resolveUserWalletId(trade.merchantId, trade.currencyTarget);
Â  Â  Â  if (!merchantDestinationId) {
Â  Â  Â  Â  trade.status = ALLOWED_STATES.FAILED;
Â  Â  Â  Â  await trade.save();
Â  Â  Â  Â  throw new Error("Merchant destination Address ID missing for reversal");
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // 2. Get Merchant's Crypto Address (REQUIRED for Blockrader's 'address' field)
Â  Â  Â  const merchantCryptoAddress = await resolveUserCryptoAddress(trade.merchantId, trade.currencyTarget);
Â  Â  Â  if (!merchantCryptoAddress) {
Â  Â  Â  Â  trade.status = ALLOWED_STATES.FAILED;
Â  Â  Â  Â  await trade.save();
Â  Â  Â  Â  throw new Error("Merchant crypto address missing for reversal");
Â  Â  Â  }

Â  Â  Â  // Pass the required 0x destination address. Source is the Master Wallet.
Â  Â  Â  // This is a Master -> Child transfer (Reversal)
Â  Â  Â  const transferResult = await blockrader.transferFunds(
Â  Â  Â  Â  blockrader.BLOCKRADER_MASTER_WALLET_UUID, // Source: Master Wallet UUID
Â  Â  Â  Â  merchantDestinationId, // Destination: Merchant UUID (used for routing)
Â  Â  Â  Â  trade.amountTarget,
Â  Â  Â  Â  trade.currencyTarget,
Â  Â  Â  Â  merchantCryptoAddress // Pass the required 0x destination address
Â  Â  Â  );

Â  Â  Â  // --- FIX 1 (CancelTrade External): Check for successful API response structure (data.id) ---
Â  Â  Â  if (!transferResult || !transferResult.data || !transferResult.data.id) {
Â  Â  Â  Â  // FIX: Use template literals (backticks)
Â  Â  Â  Â  const errorMessage = `External Escrow reversal failed at provider. Provider response: ${JSON.stringify(transferResult)}`;
Â  Â  Â  Â  console.error(errorMessage);
Â  Â  Â  Â  trade.status = ALLOWED_STATES.FAILED;
Â  Â  Â  Â  await trade.save();
Â  Â  Â  Â  throw new Error("Escrow reversal failed at provider");
Â  Â  Â  }
Â  Â  Â  // --- End Fix 1 ---

Â  Â  Â  const txId = transferResult.data.id || transferResult.txId || "n/a";
Â  Â  Â  trade.status = ALLOWED_STATES.CANCELLED_REVERSED;
Â  Â  Â  // FIX: Use template literals (backticks)
Â  Â  Â  safeLog(trade, { message: `External escrow reversed (tx:${txId})`, actor: userId, role: "system", ip, time: new Date() });
Â  Â  Â  reversalSuccess = true;
Â  Â  }

Â  Â  // Generic cancel if nothing to reverse or reversal was successful
Â  Â  if (!reversalSuccess) {
Â  Â  Â  Â  trade.status = ALLOWED_STATES.CANCELLED;
Â  Â  Â  Â  safeLog(trade, { message: "Trade cancelled (no reversal needed)", actor: userId, role: "requester", ip, time: new Date() });
Â  Â  }
Â  Â Â 
Â  Â  // Final save of the status
Â  Â  await trade.save();
Â  Â  return trade.toObject();
Â  },

Â  // Utility helpers for admin / UI
Â  async getTradeByReference(reference) {
Â  Â  return await P2PTrade.findOne({ reference }).populate("userId", "firstName email role").populate("merchantId", "firstName email role").lean();
Â  },

Â  async listTrades(filter = {}, page = 1, pageSize = 20) {
Â  Â  const q = {};
Â  Â  if (filter.status) q.status = filter.status;
Â  Â  if (filter.userId) q.userId = filter.userId;
Â  Â  if (filter.merchantId) q.merchantId = filter.merchantId;

Â  Â  const [trades, total] = await Promise.all([
Â  Â  Â  P2PTrade.find(q).sort({ createdAt: -1 }).skip((page - 1) * pageSize).limit(pageSize).lean(),
Â  Â  Â  P2PTrade.countDocuments(q)
Â  Â  ]);

Â  Â  return { trades, total, page, pageSize };
Â  }
};
